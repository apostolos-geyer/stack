#!/usr/bin/env node

import fs from "node:fs/promises";
import path from "node:path";
import { fileURLToPath } from "node:url";
import postcss from "postcss";
import {
  formatHex,
  formatCss,
  modeOklch,
  modeRgb,
  modeP3,
  useMode,
  toGamut,
  parse,
} from "culori";

// --- 1. CONFIGURATION ---

// Initialize Culori Modes
useMode(modeOklch);
useMode(modeRgb);
useMode(modeP3);

// Converters
const toRgb = toGamut("rgb");
const toP3 = toGamut("p3");

// Tailwind default base size
const REM_BASE = 16;

// Resolve paths (ESM equivalent of __dirname)
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const INPUT_CSS = path.join(__dirname, "../tokens.css");
const OUTPUT_TS = path.join(__dirname, "../tokens.ts");

// --- 2. LOGIC ---

function processValue(value) {
  const clean = value.trim();

  // A. Handle REM (Numbers)
  if (clean.endsWith("rem")) {
    const float = parseFloat(clean);
    if (!isNaN(float)) return float * REM_BASE;
  }

  // B. Handle PX (Numbers)
  if (clean.endsWith("px")) {
    const float = parseFloat(clean);
    if (!isNaN(float)) return float;
  }

  // C. Handle Colors
  // Skip calculated vars or raw numbers that act like strings
  if (!clean.startsWith("var(") && !clean.startsWith("calc")) {
    const parsed = parse(clean);
    if (parsed) {
      return {
        original: clean,
        // 1. Android/Web Fallback: Safe sRGB Hex
        hex: formatHex(toRgb(parsed)) || "#000000",
        // 2. iOS: High Fidelity P3
        p3: formatCss(toP3(parsed)) || clean,
      };
    }
  }

  // D. Fallback (Fonts, Strings, etc.)
  return clean;
}

async function generate() {
  console.log(`üé® Reading ${INPUT_CSS}...`);

  try {
    const css = await fs.readFile(INPUT_CSS, "utf8");

    const tokens = {
      light: {},
      dark: {},
    };

    const root = postcss.parse(css);

    root.walkRules((rule) => {
      const isRoot = rule.selector === ":root";
      const isDark = rule.selector === ".dark";

      if (!isRoot && !isDark) return;

      rule.walkDecls((decl) => {
        // Only process --variables
        if (decl.prop.startsWith("--")) {
          const key = decl.prop.replace(/^--/, "");
          const target = isRoot ? tokens.light : tokens.dark;

          target[key] = processValue(decl.value);
        }
      });
    });

    // --- 3. OUTPUT WITH TYPE MAGIC ---

    const fileContent = `// @generated by packages/styles/scripts/gen-tokens.mjs
// DO NOT EDIT MANUALLY - Source: packages/styles/tokens.css

export type ColorToken = {
  original: string;
  hex: string;
  p3: string;
};

export const TOKENS = {
  light: ${JSON.stringify(tokens.light, null, 2)},
  dark: ${JSON.stringify(tokens.dark, null, 2)},
} as const;

export type LightTheme = typeof TOKENS.light;

/**
 * TYPE MAGIC:
 * Extracts ONLY the keys from the theme that are ColorTokens.
 * Excludes numbers (radius) and strings (fonts).
 */
export type ThemeColors = {
  [K in keyof LightTheme]: LightTheme[K] extends ColorToken ? K : never
}[keyof LightTheme];
`;

    await fs.writeFile(OUTPUT_TS, fileContent);
    console.log(`‚úÖ Generated ${OUTPUT_TS}`);
  } catch (error) {
    console.error("‚ùå Error generating tokens:", error);
    process.exit(1);
  }
}

generate();
